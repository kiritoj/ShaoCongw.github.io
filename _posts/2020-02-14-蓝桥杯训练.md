---
layout:     post
title:      蓝桥杯训练（5）
subtitle:   第五届
date:       2020-02-14
author:     taoke
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - 蓝桥杯
---

 

# 1.啤酒和饮料（填空）

 啤酒每罐2.3元，饮料每罐1.9元。小明买了若干啤酒和饮料，一共花了82.3元。我们还知道他买的啤酒比饮料的数量少，请你计算他买了几罐啤酒。

注意：答案是一个整数。请通过浏览器提交答案。

暴力枚举

```java
public static void main(String[] args) {
    int maxPeer = (int) (82.3 / 2.3);
    for (int i = 1; i <= maxPeer; i++) {
        for (int j = i+1; j <= (82.3-2.3*i)/1.9 ; j++) {
            if (2.3*i + 1.9*j == 82.3){
                System.out.println(i);
                break;
            }
        }
    }
}
```

答案：11



# 2.切面条（填空）

  一根高筋拉面，中间切一刀，可以得到2根面条。


    如果先对折1次，中间切一刀，可以得到3根面条。


    如果连续对折2次，中间切一刀，可以得到5根面条。


​    那么，连续对折10次，中间切一刀，会得到多少面条呢？  



自己做几次找规律

对折3次，可以得到9根面条

2,3,5,9规律已经出来的，等于前一次的两倍-1

```java
public static void main(String[] args) {
    int count = 2;
    for (int i = 1; i <= 10 ; i++) {
        count = count*2 - 1;
    }
    System.out.println(count);
}
```

答案：1025

# 3.李白打酒（填空）

 话说大诗人李白，一生好饮。幸好他从不开车。


    一天，他提着酒壶，从家里出来，酒壶中有酒2斗。他边走边唱：


    无事街上走，提壶去打酒。
    逢店加一倍，遇花喝一斗。


    这一路上，他一共遇到店5次，遇到花10次，已知最后一次遇到的是花，他正好把酒喝光了。 


    请你计算李白遇到店和花的次序，可以把遇店记为a，遇花记为b。则：babaabbabbabbbb 就是合理的次序。像这样的答案一共有多少呢？请你计算出所有可能方案的个数（包含题目给出的）。
```java
/**
 *
 * @param peer 目前还剩余的酒量
 * @param shop 已经遇到过几个商店
 * @param flower 已经遇到花的次数
 * @return
 */
    public static int getSorts(int peer, int shop ,int flower){
        //不可能的情况
        if (shop > 5 || flower > 9 || peer < 0){
            return 0;
        }
        //已经走了5个商店，遇到9次花，因为最后一次一定是花，酒还剩1斗
        if (shop == 5 && flower == 9 && peer == 1){
            return 1;
        }
        return getSorts(peer*2,shop+1,flower) + getSorts(peer - 1,shop,flower + 1);
    }
```

# 6.奇怪的分式

 上小学的时候，小明经常自己发明新算法。一次，老师出的题目是：


    1/4 乘以 8/5 


    小明居然把分子拼接在一起，分母拼接在一起，答案是：18/45 （参见图1.png）


    老师刚想批评他，转念一想，这个答案凑巧也对啊，真是见鬼！


    对于分子、分母都是 1~9 中的一位数的情况，还有哪些算式可以这样计算呢？


    请写出所有不同算式的个数（包括题中举例的）。


    显然，交换分子分母后，例如：4/1 乘以 5/8 是满足要求的，这算做不同的算式。


    但对于分子分母相同的情况，2/2 乘以 3/3 这样的类型太多了，不在计数之列!
————————————————
又是暴力解题

```java
public static void main(String[] args) {
    int count = 0;
    for (int i = 1; i < 10; i++) {
        for (int j = 1; j < 10; j++) {
            for (int k = 1; k < 10; k++) {
                for (int l = 1; l < 10; l++) {
                    if (i == j && k == l){
                        continue;
                    }
                    if ((double)(i*k)/(j*l) == (double)(i*10+k)/(j*10+l)){
                        count++;
                    }
                }
            }
        }
    }
    System.out.println(count);
}
```

# 7.六角填数（DFS）


​    如图【1.png】所示六角形中，填入1~12的数字。


​    使得每条直线上的数字之和都相同。


​    图中，已经替你填好了3个数字，请你计算星号位置所代表的数字是多少？  

可以用暴力枚举法，但是这是一个和明显的dfs问题

![](https://img-blog.csdn.net/20160124192951002?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

将空白部分（包括星号）9和位置按层次遍历设置为a[0]~a[8],则星号的位置是a[3]

```java
public static int getStarValue(){
    //预选的可填值
    int[] visit = {2,4,5,6,7,9,10,11,12};
    boolean[] isVis = new boolean[9];
    for (int i = 0; i < isVis.length; i++) {
        isVis[i] = false;
    }
    //存储空白值
    int[] num = new int[9];
    return dfs(visit,num,0,isVis);
}
```

```java
public static int dfs(int[] visit, int[] num,int n,boolean[] vis){
    if (n == 9){
        if (isRight(num)){
            return num[3];
        }else{
            return -1;
        }
    }
    int result = 0;
    for (int i = 0; i < 9; i++) {
        //已经访问过了
        if (vis[i]){
            continue;
        }
        num[n] = visit[i];
        vis[i] = true;
        result = dfs(visit,num,n+1,vis);
        vis[i] = false;
        if (result > 0){
            break;
        }
    }
    return result;
}
```

```java
public static boolean isRight(int[] num){
    int v1 = 1 + num[0] + num[3] + num[5];
    int v2 = 1 + num[1] + num[4] + num[8];
    int v3 = num[5] + num[6] + num[7] + num[8];
    int v4 = 8 + num[3] + num[6] + 3;
    int v5 = 8 + num[0] + num[1] + num[2];
    int v6 = num[2] + num[4] + num[7] + 3;
    if (v1 == v2 && v1 == v3 && v1 == v4 && v1 == v5 && v1 == v6){
        return true;
    }
    return false;
}
```

# 8.蚂蚁感冒

**问题描述**

　　长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。

　　每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。

　　当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。

　　这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。

　　请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。

------

**输入格式**

　　第一行输入一个整数n (1 < n < 50), 表示蚂蚁的总数。

　　接着的一行是n个用空格分开的整数 Xi (-100 < Xi < 100), Xi的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现0值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了。

输出格式

　　要求输出1个整数，表示最后感冒蚂蚁的数目。

------

**样例输入**

3
5 -2 8

**样例输出**

1

**样例输入**

5
-10 8 -20 12 25

**样例输出**

3



从网上看来的思路

两只蚂蚁相遇后，如果都没病，相遇后也都没病。犹如有任何一只有病，则两只都有病。问题可简化为相遇后不是掉头，而是直接穿过

这里以第一只感冒的蚂蚁向右走例，如果它右边的蚂蚁也全部向右走。则不会传染，最后只有1只蚂蚁感染了。

如果它右边有向左的蚂蚁，必然全被感染，向左穿过去的蚂蚁还会感染左边向右移动的蚂蚁

```java
public static int getGanMaoCount(int[] dis){
    int lr = 0;//左边向右移动的蚂蚁
    int rl = 0;//右边向左移动的蚂蚁
    for (int i = 1; i < dis.length; i++) {
        if (Math.abs(dis[i]) < Math.abs(dis[0])){
            if (dis[i] > 0){
                lr++;
            }
        }else{
            if (dis[i] < 0){
                rl++;
            }
        }
    }
    //第一只蚂蚁向左移动
    if (dis[0] < 0){
        return lr == 0 ? 1 : lr + rl + 1;
    }else{
        //第一只蚂蚁向右移动
        return rl == 0 ? 1 : lr + rl + 1;
    }
}
```

