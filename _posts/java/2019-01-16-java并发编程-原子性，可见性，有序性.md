---
layout:     post
title:      java并发编程-原子性，可见性，有序性
subtitle:   nothing
date:       2019-01-16
author:     Taoke
header-img: img/post_jinxiu1.jpg
catalog: true
tags:
    - java
    - 并发编程
    
---

# 原子性

一个操作或一组操作，要么全部完成且不会被打断，要么就全都不执行。

经典案例：**银行转账问题**

A转账1000给B，其中包含两个操作，从A的账户中扣除1000元，B的账户增加1000元。这两个操作要么全部完成，要么都不完成，否则就会出现错误。

分辨下列操作哪些是原子操作

```java
i = 0; //基本数据类型的变量的赋值操作是原子操作
j = i; //1.读取i的值 2.将i的值赋给j
i++;   //1.读取i值 2.i+1 3.i+1的值赋给i
i = j + 1;//同上
```

在**单线程环境下**，以上操作均可以认为是原子操作。在**多线程环境下**，只有第一条是原子操作,可通过**lock**，**synchronized**保证原子性，**volatile不保证原子性**

注：在32位JDK环境下，对64位数据类型不是原子操作，long，double

# 可见性

多个线程访问同一个变量时，当其中一个进程修改了变量的值，其他进程能够**立即看见修改后的值**

例如：

线程1执行

```java
int i = 0；
i = 10；
```

线程2

```java
j = i；
```

首先说一下计算机的存储结构，包括**高速缓存（cache），主存（内存，RAM，ROM），外存（磁盘，磁带，光盘）**

 假设执行线程1的是CPU1，执行线程2的是CPU2。

**线程1**的执行过程：把i的初始值读到CPU1的cache中，并赋值为10，但还没有立即写回主存中（此处认为是内存），什么时候写回不确定。

如果此时**线程2**执行j = i;会首先从内存中读取i的值，由于还没有写回，因此内存中的值还是0。也就是说，线程2对线程 1的修改是不可见的。

使用**volatile**关键字保证可见性，volatile的作用：**禁止指令重排序**（涉及有序性问题），保证共享变量的值被修改后**立即写回主存**

同样可以使用lock和synchronized关键字保证可见性，保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中

# 有序性

使程序按照代码的先后顺序执行

**代码段1**

```
int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句2
```

事实上，**语句1不一定在语句2前面执行**，这里可能发生了**指令重排序**

**指令重排序**：在不影响最终结果的前提下，为了提高程序运行效率，可能会对代码进行优化，修改代码的执行顺序，但保证最终结果和顺序执行是结果是一样的。

**代码段2**

```
int a = 10;    //语句1
int r = 2;     //语句2
a = a + 3;     //语句3
r = a*a;       //语句4
```

**可能的执行顺序**

1-2-3-4

2-1-3-4

修改顺序对最终结果无影响

**不可能的执行顺序**

2-1-4-3

最终结果与顺序执行的结果不一致



指令重排序对单线程环境下对执行结果没有影响，但多线程中有

```java
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2

//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
```

由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。

**并发编程必须保证原子性，有序性，可见性。**

写操作先于读操作

[参考来源](http://www.jianshu.com)

