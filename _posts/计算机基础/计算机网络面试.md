## 计算机网络面试

## 链路层

### 三个问题

* 封装成帧

将IP数据报加上首部和尾部组成一个帧

* 透明传输

帧的数据部分可能出现和首部尾部相同的部分，导致错误的判断一个帧的首部和尾部。在相同部分前面加上转义字符，在接收端处理过后可以还原出原始数据

* 差错检测

循环冗余检测

发送端对数据进行分组，每组k个比特

M = 101001（k = 6）

双方约定n位冗余码，假设为3

M后面添加n个0，再除以双方约定好的（n+1）位除数

得到n位冗余码，加在M后面，一起发送过去（k+n）位



接收端收到以后同样除以除数，余数为0则判断帧没有出错，反之这个帧有错误



### MAC地址

6字节48位，有多少个网络适配器（网卡）就有多少个MAC地址，一对一

### 帧格式

目的MAC地址（6字节）源MAC地址（6字节）类型（2字节）数据部分（46-1500字节）冗余码（4字节）

MTU：最大传输单元，1500字节

上层的IP数据报最大为1500字节，最小为46字节（满足帧最小大小为64字节）

### 交换机

独占传输媒体，无碰撞地传输数据

**交换表**自学习功能

交换机是工作在同一个局域网中，即负责同一个局域网中主机间传输帧

目的MAC地址 | 接口

交换表为空的情况：

**A从接口1向B发送一帧**

1.交换表中查找目的MAC地址，没有找到，向接口1以外的所有接口广播这个帧，若交换表中没有A的MAC地址，则新增。否则更新

2.主机B接受下这个帧，其余主机丢弃（目的MAC地址不对）

**B从接口3向A发送一帧**

1.查找交换表，有A的MAC地址，直接从接口1转发。若交换表中没有B的MAC地址，则新增，否则更新



总之，交换表中的数据都是发送端写入的。而且有有效时间，过期会被删除。原因是交换机接口更换主机或者主机的网卡换了。

## 网络层

* 分类
* 子网划分
* 无分类

### 分类

4字节32位

A类 ：0 + 7位网络号 + 24位主机号

B类：10 + 14位网络号+16位主机号

C类：110 + 21位网络号 + 8位主机号

D类：1110 + 多播地址

E类：1111 + 保留



### 划分子网

主机号拿出一部分作为子网络号

原因：IP地址空间利用率比较低，一个网络真正存在的主机可能远远小于最大主机数

​            两级IP地址不够灵活，新的子网可以立即工作

子网对外仍然表现为1个网络

子网掩码：网络号+子网号。**和IP地址与操作**，得到子网的网络地址



### 无分类

网络前缀+主机号

子网掩码：网络前缀为1，同样进行与操作，得到网络前缀，代表一个网络

### 地址解析协议ARP

IP地址 ——> MAC地址

主机存在一个ARP高速缓存

**主机A向本局域网的某台主机发送IP数据报时**，要将B的IP地址转换为MAC地址封装成帧。

若没有B的IP地址，广播一个ARP请求分组，写入自己的地址映射。

其他主机不理会，主机B接收到请求分组，将A的地址映射写入到缓存中，向A发送一个ARP响应分组，写入主机B的地址映射。

A收到响应分组，把B的地址映射写入到缓存中

发送端和接收端都更新缓存地址映射

### 路由器

只有3层，物理层、链路层、网络层

链路层收到帧以后，剥离首部和尾部，然后重新加上新的首部和尾部（更新源MAC和目的MAC），将帧发送给下一个路由器或者主机

路由表

**分类**

目的主机所在网络地址 | 下一跳地址

分组转发算法

1、提取IP数据报目的IP地址D，得到目的网络地址N

2、N是路由器直接连接的网络（两个），通过接口直接交付

3、D存在特定路由，执行下一跳

4、路由表存在D的下一跳地址，执行下一跳

5、存在D的默认路由，执行下一跳

6、分组出错

**子网划分**

目的主机所在网络（子网） | 子网掩码 |下一跳地址

和分类相比的差别是，每次拿到IP地址获取网络地址时，要和每一项的目的地址的子网掩码与运算，得到目的网络

其他步骤一样



**无分类**

最长前缀匹配

IP地址与子网掩码与操作，选择最长前缀匹配的。

其他操作一样

**无分类**

### IP数据报首部

固定20字节，40字节的可变长度

首部常用字段

**总长度**：首部+数据

**标识**：分片后，各数据报片具有相同的标识

**标志**：MF = 1还有分片，MF = 0没有分片

​           DF = 1不能分片

**片偏移**：每一个分片数据部分一定是8字节的整数倍，数据报片的数据部分在原来数据报数据部分的相对位置

以数据部分1400字节分片

第一个分片的片偏移 = 0

第二个分片的片偏移 = 1400 /8 = 175;

**原地址**

**目的地址**

**首部检验和**

只检验首部，不检验数据。

发送方将首部以16位划分，相加取反后写入检验和字符安

接收方接受后，同样 16位划分，加起来与检验和字段相加，结果为0，则保留



### 网关协议

**内部网关协议RIP**

基于距离向量，路由器维护从自己到目的网络的距离，直接相连的网络距离为1，每经过一个路由器+1。距离等于16时不可达，仅使用小型网络

仅和相邻路由器交换信息

距离向量算法

路由器R6，R4

目的网络 | 距离 |下一跳

R6收到R4的RIP报文。将R4的报文修改，所有下一跳地址变为R4，距离+1

R6中没有R4的目的网络，则直接添加R4的这一项

R6有R4中的目的网络，且下一跳是R4，直接更新距离

下一跳不是R4，比较距离。如下一跳是R4更短，则更新距离和下一跳。

若3分钟还没有收到相邻路由器的RIP报文，则将此路由器距离设置为16不可达

**内部网关协议OSPF**

和本自治系统的所有路由器交换信息

**外部网关协议BGP**

BGP（Border Gateway Protocol，边界网关协议）

AS 之间的路由选择很困难，主要是由于：

- 互联网规模很大；
- 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；
- AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。

BGP 只能寻找一条比较好的路由，而不是最佳路由。

每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。



## 传输层

常用端口号

FTP：21

DNS：53

HTTP：80；

HTTPS：443

**TCP和UDP的区别？**

UDP

1、无连接

2、尽最大努力交互

3、面向报文

对应用层交下来的报文，不合并不拆分。加上首部直接发送给。对于网络层交上来的数据报，去除首部后直接交付上层。一次交付一个完整的报文

4、没有拥塞控制

5、支持一对一、一对多、多对一、多对多的交互通信

6.首部只有8个字节



TCP

1、面向连接

三次握手和四次挥手

2、保证可靠的交付

3、面向字节流

4、有拥塞控制

5、每一条TCP连接只支持一对一的通信

这并不是一个客户端和服务端只能一对一通信。同一个IP地址或者端口号可以有多个不同的TCP连接

6.首部默认20个字节

### 停止等待协议

每发送完一个分组，等待对方的确认。没有收到确认就超时重传，直到收到确认。发送下一个分组

### 连续ARQ协议

停止等待协议存在明显的效率问题

发送方维护一个发送分组，每个分组按序号排序，发送窗口内的分口按顺序都可以发送出去。发送方每收到一个确认，就把发送窗口前移一个分组的位置

接收方累积确认，对按序到达的最后一个分组发送确认，到表示这个分组的所有分组都收到了

### TCP首部字段

源端口

目的端口

序号：字节流中每一个字节顺序编号，表示的是**本报文段**第一个字节的序号

例如一个报文段序号字段是301，说明第一个字节在字节流中的序号是301。如果有100个字节，则下一个报文段的序号是401



确认号（ack）：表示到**该序号之前**的数据都收到了，期望对方下一个报文段是序号是这个数字

确认ACK：当ACK=1,时，确认号才有效。连接建立后ACK = 1；

同步SYN：建立连接

​                  SYN = 1，ACK = 0。连接请求

​                  SYN = 1， ACK = 1。连接接受

中止FIN：释放连接，FIN = 1

窗口：接收方的接受窗口，用于给发送方设置发送窗口

### TCP可靠传输的实现

TCP的发送窗口以字节为单位

发送窗口前的代表已发送并收到确认

发送窗口中的代表可发送，又包括两部分（已发送未收到确认、还未发送——可用窗口）

发送窗口后的代表不允许发送



对于不按序到达的数据，存在接收窗口。

发送方发送的报文段没有在超时时间内收到确认，就会超时重传。重传时间与加权往返时间RTT有关

#### TCP的UDP的应用场景

TCP：效率要求较低，准确性要求较高。因为TCP要进行连接，确认

重传等。适用于文件传输，邮件等

UDP；效率要求较高，视频通话，音频通话。偶尔出现断续不会有太大影响



### TCP拥塞控制

防止过多的数据注入到网络中，使网络中的路由器和链路不至于过载。是个全局性的过程

流量控制是点对点问题，比如发送的发送窗口收到接收方接收窗口的限制，当窗口 = 0，发送方不能发送数据

* 慢开始

  发送方每收到一个新的报文段确认，拥塞窗口就增大一个最大报文段数值

  每经过一个传输轮次，拥塞窗口就加倍

* 拥塞避免，当拥塞窗口值等于一个慢开始门限，就可以使用拥塞避免算法

  每个轮次只增加一个最大报文段数值，规律加法增大

  如果出现超时，慢开始门限减半、拥塞窗口设为1

* 快重传

  个别报文段丢失，但网络并未出现拥塞。要求接收方立即重复3次确认已收到的报文段。发送方就知道不是拥塞，而是要重传丢失的报文段

* 快恢复

  快重传之后，拥塞窗口减半，慢开始门限等于减半后的拥塞窗口



**发送方的发送窗口同时受到拥塞窗口和接收窗口的限制**

### 三次握手

![](https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3428363803,4186045685&fm=26&gp=0.jpg)

SYN和FIN报文段一定要消耗一个序号

ACK报文段如果不携带数据就不消耗序列号

* 客户端发送一个SYN报文段，进入SYN-SENT状态

* 服务端受到这个报文段后发送一个SYN+ACK的确认报文段没进入SYN-RCVD状态
* 客户端受到确认后再发送一个ACK报文段，进入established状态，服务端tcp连接建立

为什么要三次？

防止已经失效的连接请求报文段到达服务端后出现问题。如果只有两次握手，比如客户端的第一个SYN报文段迟到了，客户端重传建立连接。通信结束后，连接释放。这时这个SYN报文段达到了服务端，服务端发送确认认为已经建立连接了。但客户端并没有和服务端通信的需求，服务端的资源浪费。三次握手，客户端不会理会这个确认，连接就不会建立。



### 四次挥手

![](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4097066795,1217965833&fm=26&gp=0.jpg)

* 客户端发送一个FIN报文段请求连接释放，进入FIN-WAIT1
* 服务端确认，发送ACK报文段，进入CLOSE-WAIT
* 客户端受到确认，进入FIN-WAIT2状态。
* 服务端向客户端发出一个FIN+ACK报文段，进入LAST-ACK状态
* 客户端发送ACK确认报文段，进入TIME-Wait抓那个太
* 服务端受到确认，进入CLOse
* 客户端2MSL时间后才可以关闭



为何要经过2MSL?

保证客户端的最后一个ACK确认报文段能够到达服务端。A发出的这个ACK确认报文段可能会丢失，B就会超时重传FIN+ACK报文段，A就会重传这个ACK，重启计时器

防止已经失效的连接请求报文段出现在下次连接中，2MSL内，本次连接持续时间内所产生的所有报文段都从网络中消失了。

## 应用层

### DNS解析

域名结构：顶级域名、二级域名、三级域名...

![1600271057089](C:\Users\MIFANS\AppData\Roaming\Typora\typora-user-images\1600271057089.png)

域名服务器，不是以域为单位，而是通过划分区的方式，每一个区都有**权限域名服务器**，存储域名到Ip地址的映射

![1600271595865](C:\Users\MIFANS\AppData\Roaming\Typora\typora-user-images\1600271595865.png)

本地域名服务器：主机发出一个DNS查询请求，这个查询请求首先发送给本地域名服务器

主机向本地域名服务器一般通过递归查询

本地域名服务器向根域名服务器一般通过迭代查询

![1600274301637](C:\Users\MIFANS\AppData\Roaming\Typora\typora-user-images\1600274301637.png)