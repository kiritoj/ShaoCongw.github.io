# MVC，MVP，MVVM面试

**以上三种架构，M层代表业务逻辑，始终未变。VX表现层**

以前错误的理解，P层或者VM用来处理业务逻辑，实际上他们是将controller的**表现层逻辑**转移过来

**表现层逻辑**

最简单的，一个view什么时候隐藏，什么时候出现

音乐播放器控制按钮的显示逻辑等

网络请求时，P根据请求的结果或者无法连接网络决定让V去显示对应的视图

一列信息流，删掉其中一个，或者新增一个

一次获取到很多task，只想要某一个种类的task，分类交给presenter了

**流程**

View层（包括Activity）接收事件，然后通知P或者VM，执行表现逻辑。通知View更新，接口或者databinding。View不处理表现层逻辑，只定义一些显示视图的方法，被动更新视图



**单元测试**

P或VM和Android视图无关，只包含表现层逻辑，可以很方便地进行单元测试



**静态的Bean类不能代表M层（V），Model就是负责数据获取的（X）**

还包括对数据的增删改查，组装处理。关于等于数据的增删改查应该在封装repository中，由Model调用，对得到的数据执行业务逻辑处理。Model并不关心数据源怎么来的，数据源改变只要逻辑不变Model就可以保持不变。当然，Repo也是Model层的一部分

比如要在信息流中插入广告，广告可以从广告Repo中获取，但是插入进信息流就是Modle的工作了，这就是业务逻辑



**MVC的不足**

xml作为View层能力太弱，一些视图的显示逻辑还需要activity用代码的方式解决，所以activity同时承担了Controller和View的职责，导致表现层逻辑和视图耦合在一起。另外，M层和View也存在耦合（传入接口更新数据）

**MVVM和MVP的区别**

差别不大，P层是通过持有view的引用更新的UI；VM是通过databinding和LivaData更新数据。省去了MVP模式定义的大量接口





